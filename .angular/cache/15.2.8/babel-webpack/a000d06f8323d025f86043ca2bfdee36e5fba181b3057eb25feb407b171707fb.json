{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Socket = exports.RESERVED_EVENTS = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst typed_events_1 = require(\"./typed-events\");\nconst base64id_1 = __importDefault(require(\"base64id\"));\nconst broadcast_operator_1 = require(\"./broadcast-operator\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nconst RECOVERABLE_DISCONNECT_REASONS = new Set([\"transport error\", \"transport close\", \"forced close\", \"ping timeout\", \"server shutting down\", \"forced server close\"]);\nexports.RESERVED_EVENTS = new Set([\"connect\", \"connect_error\", \"disconnect\", \"disconnecting\", \"newListener\", \"removeListener\"]);\nfunction noop() {}\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */\nclass Socket extends typed_events_1.StrictEventEmitter {\n  /**\n   * Interface to a `Client` for a given `Namespace`.\n   *\n   * @param {Namespace} nsp\n   * @param {Client} client\n   * @param {Object} auth\n   * @package\n   */\n  constructor(nsp, client, auth, previousSession) {\n    super();\n    this.nsp = nsp;\n    this.client = client;\n    /**\n     * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n     * be transmitted to the client, the data attribute and the rooms will be restored.\n     */\n    this.recovered = false;\n    /**\n     * Additional information that can be attached to the Socket instance and which will be used in the\n     * {@link Server.fetchSockets()} method.\n     */\n    this.data = {};\n    /**\n     * Whether the socket is currently connected or not.\n     *\n     * @example\n     * io.use((socket, next) => {\n     *   console.log(socket.connected); // false\n     *   next();\n     * });\n     *\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.connected); // true\n     * });\n     */\n    this.connected = false;\n    this.acks = new Map();\n    this.fns = [];\n    this.flags = {};\n    this.server = nsp.server;\n    this.adapter = this.nsp.adapter;\n    if (previousSession) {\n      this.id = previousSession.sid;\n      this.pid = previousSession.pid;\n      previousSession.rooms.forEach(room => this.join(room));\n      this.data = previousSession.data;\n      previousSession.missedPackets.forEach(packet => {\n        this.packet({\n          type: socket_io_parser_1.PacketType.EVENT,\n          data: packet\n        });\n      });\n      this.recovered = true;\n    } else {\n      if (client.conn.protocol === 3) {\n        // @ts-ignore\n        this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n      } else {\n        this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n      }\n\n      if (this.server._opts.connectionStateRecovery) {\n        this.pid = base64id_1.default.generateId();\n      }\n    }\n    this.handshake = this.buildHandshake(auth);\n  }\n  /**\n   * Builds the `handshake` BC object\n   *\n   * @private\n   */\n  buildHandshake(auth) {\n    return {\n      headers: this.request.headers,\n      time: new Date() + \"\",\n      address: this.conn.remoteAddress,\n      xdomain: !!this.request.headers.origin,\n      // @ts-ignore\n      secure: !!this.request.connection.encrypted,\n      issued: +new Date(),\n      url: this.request.url,\n      // @ts-ignore\n      query: this.request._query,\n      auth\n    };\n  }\n  /**\n   * Emits to this client.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.emit(\"hello\", \"world\");\n   *\n   *   // all serializable datastructures are supported (no need to call JSON.stringify)\n   *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n   *\n   *   // with an acknowledgement from the client\n   *   socket.emit(\"hello\", \"world\", (val) => {\n   *     // ...\n   *   });\n   * });\n   *\n   * @return Always returns `true`.\n   */\n  emit(ev, ...args) {\n    if (exports.RESERVED_EVENTS.has(ev)) {\n      throw new Error(`\"${String(ev)}\" is a reserved event name`);\n    }\n    const data = [ev, ...args];\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: data\n    };\n    // access last argument to see if it's an ACK callback\n    if (typeof data[data.length - 1] === \"function\") {\n      const id = this.nsp._ids++;\n      debug(\"emitting packet with ack id %d\", id);\n      this.registerAckCallback(id, data.pop());\n      packet.id = id;\n    }\n    const flags = Object.assign({}, this.flags);\n    this.flags = {};\n    // @ts-ignore\n    if (this.nsp.server.opts.connectionStateRecovery) {\n      // this ensures the packet is stored and can be transmitted upon reconnection\n      this.adapter.broadcast(packet, {\n        rooms: new Set([this.id]),\n        except: new Set(),\n        flags\n      });\n    } else {\n      this.notifyOutgoingListeners(packet);\n      this.packet(packet, flags);\n    }\n    return true;\n  }\n  /**\n   * Emits an event and waits for an acknowledgement\n   *\n   * @example\n   * io.on(\"connection\", async (socket) => {\n   *   // without timeout\n   *   const response = await socket.emitWithAck(\"hello\", \"world\");\n   *\n   *   // with a specific timeout\n   *   try {\n   *     const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n   *   } catch (err) {\n   *     // the client did not acknowledge the event in the given delay\n   *   }\n   * });\n   *\n   * @return a Promise that will be fulfilled when the client acknowledges the event\n   */\n  emitWithAck(ev, ...args) {\n    // the timeout flag is optional\n    const withErr = this.flags.timeout !== undefined;\n    return new Promise((resolve, reject) => {\n      args.push((arg1, arg2) => {\n        if (withErr) {\n          return arg1 ? reject(arg1) : resolve(arg2);\n        } else {\n          return resolve(arg1);\n        }\n      });\n      this.emit(ev, ...args);\n    });\n  }\n  /**\n   * @private\n   */\n  registerAckCallback(id, ack) {\n    const timeout = this.flags.timeout;\n    if (timeout === undefined) {\n      this.acks.set(id, ack);\n      return;\n    }\n    const timer = setTimeout(() => {\n      debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n      this.acks.delete(id);\n      ack.call(this, new Error(\"operation has timed out\"));\n    }, timeout);\n    this.acks.set(id, (...args) => {\n      clearTimeout(timer);\n      ack.apply(this, [null, ...args]);\n    });\n  }\n  /**\n   * Targets a room when broadcasting.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // the “foo” event will be broadcast to all connected clients in the “room-101” room, except this socket\n   *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n   *\n   *   // the code above is equivalent to:\n   *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n   *\n   *   // with an array of rooms (a client will be notified at most once)\n   *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n   *\n   *   // with multiple chained calls\n   *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n   * });\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  to(room) {\n    return this.newBroadcastOperator().to(room);\n  }\n  /**\n   * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // disconnect all clients in the \"room-101\" room, except this socket\n   *   socket.in(\"room-101\").disconnectSockets();\n   * });\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  in(room) {\n    return this.newBroadcastOperator().in(room);\n  }\n  /**\n   * Excludes a room when broadcasting.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n   *   // and this socket\n   *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n   *\n   *   // with an array of rooms\n   *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n   *\n   *   // with multiple chained calls\n   *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n   * });\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  except(room) {\n    return this.newBroadcastOperator().except(room);\n  }\n  /**\n   * Sends a `message` event.\n   *\n   * This method mimics the WebSocket.send() method.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.send(\"hello\");\n   *\n   *   // this is equivalent to\n   *   socket.emit(\"message\", \"hello\");\n   * });\n   *\n   * @return self\n   */\n  send(...args) {\n    this.emit(\"message\", ...args);\n    return this;\n  }\n  /**\n   * Sends a `message` event. Alias of {@link send}.\n   *\n   * @return self\n   */\n  write(...args) {\n    this.emit(\"message\", ...args);\n    return this;\n  }\n  /**\n   * Writes a packet.\n   *\n   * @param {Object} packet - packet object\n   * @param {Object} opts - options\n   * @private\n   */\n  packet(packet, opts = {}) {\n    packet.nsp = this.nsp.name;\n    opts.compress = false !== opts.compress;\n    this.client._packet(packet, opts);\n  }\n  /**\n   * Joins a room.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // join a single room\n   *   socket.join(\"room1\");\n   *\n   *   // join multiple rooms\n   *   socket.join([\"room1\", \"room2\"]);\n   * });\n   *\n   * @param {String|Array} rooms - room or array of rooms\n   * @return a Promise or nothing, depending on the adapter\n   */\n  join(rooms) {\n    debug(\"join room %s\", rooms);\n    return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));\n  }\n  /**\n   * Leaves a room.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // leave a single room\n   *   socket.leave(\"room1\");\n   *\n   *   // leave multiple rooms\n   *   socket.leave(\"room1\").leave(\"room2\");\n   * });\n   *\n   * @param {String} room\n   * @return a Promise or nothing, depending on the adapter\n   */\n  leave(room) {\n    debug(\"leave room %s\", room);\n    return this.adapter.del(this.id, room);\n  }\n  /**\n   * Leave all rooms.\n   *\n   * @private\n   */\n  leaveAll() {\n    this.adapter.delAll(this.id);\n  }\n  /**\n   * Called by `Namespace` upon successful\n   * middleware execution (ie: authorization).\n   * Socket is added to namespace array before\n   * call to join, so adapters can access it.\n   *\n   * @private\n   */\n  _onconnect() {\n    debug(\"socket connected - writing packet\");\n    this.connected = true;\n    this.join(this.id);\n    if (this.conn.protocol === 3) {\n      this.packet({\n        type: socket_io_parser_1.PacketType.CONNECT\n      });\n    } else {\n      this.packet({\n        type: socket_io_parser_1.PacketType.CONNECT,\n        data: {\n          sid: this.id,\n          pid: this.pid\n        }\n      });\n    }\n  }\n  /**\n   * Called with each packet. Called by `Client`.\n   *\n   * @param {Object} packet\n   * @private\n   */\n  _onpacket(packet) {\n    debug(\"got packet %j\", packet);\n    switch (packet.type) {\n      case socket_io_parser_1.PacketType.EVENT:\n        this.onevent(packet);\n        break;\n      case socket_io_parser_1.PacketType.BINARY_EVENT:\n        this.onevent(packet);\n        break;\n      case socket_io_parser_1.PacketType.ACK:\n        this.onack(packet);\n        break;\n      case socket_io_parser_1.PacketType.BINARY_ACK:\n        this.onack(packet);\n        break;\n      case socket_io_parser_1.PacketType.DISCONNECT:\n        this.ondisconnect();\n        break;\n    }\n  }\n  /**\n   * Called upon event packet.\n   *\n   * @param {Packet} packet - packet object\n   * @private\n   */\n  onevent(packet) {\n    const args = packet.data || [];\n    debug(\"emitting event %j\", args);\n    if (null != packet.id) {\n      debug(\"attaching ack callback to event\");\n      args.push(this.ack(packet.id));\n    }\n    if (this._anyListeners && this._anyListeners.length) {\n      const listeners = this._anyListeners.slice();\n      for (const listener of listeners) {\n        listener.apply(this, args);\n      }\n    }\n    this.dispatch(args);\n  }\n  /**\n   * Produces an ack callback to emit with an event.\n   *\n   * @param {Number} id - packet id\n   * @private\n   */\n  ack(id) {\n    const self = this;\n    let sent = false;\n    return function () {\n      // prevent double callbacks\n      if (sent) return;\n      const args = Array.prototype.slice.call(arguments);\n      debug(\"sending ack %j\", args);\n      self.packet({\n        id: id,\n        type: socket_io_parser_1.PacketType.ACK,\n        data: args\n      });\n      sent = true;\n    };\n  }\n  /**\n   * Called upon ack packet.\n   *\n   * @private\n   */\n  onack(packet) {\n    const ack = this.acks.get(packet.id);\n    if (\"function\" == typeof ack) {\n      debug(\"calling ack %s with %j\", packet.id, packet.data);\n      ack.apply(this, packet.data);\n      this.acks.delete(packet.id);\n    } else {\n      debug(\"bad ack %s\", packet.id);\n    }\n  }\n  /**\n   * Called upon client disconnect packet.\n   *\n   * @private\n   */\n  ondisconnect() {\n    debug(\"got disconnect packet\");\n    this._onclose(\"client namespace disconnect\");\n  }\n  /**\n   * Handles a client error.\n   *\n   * @private\n   */\n  _onerror(err) {\n    if (this.listeners(\"error\").length) {\n      this.emitReserved(\"error\", err);\n    } else {\n      console.error(\"Missing error handler on `socket`.\");\n      console.error(err.stack);\n    }\n  }\n  /**\n   * Called upon closing. Called by `Client`.\n   *\n   * @param {String} reason\n   * @param description\n   * @throw {Error} optional error object\n   *\n   * @private\n   */\n  _onclose(reason, description) {\n    if (!this.connected) return this;\n    debug(\"closing socket - reason %s\", reason);\n    this.emitReserved(\"disconnecting\", reason, description);\n    if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {\n      debug(\"connection state recovery is enabled for sid %s\", this.id);\n      this.adapter.persistSession({\n        sid: this.id,\n        pid: this.pid,\n        rooms: [...this.rooms],\n        data: this.data\n      });\n    }\n    this._cleanup();\n    this.nsp._remove(this);\n    this.client._remove(this);\n    this.connected = false;\n    this.emitReserved(\"disconnect\", reason, description);\n    return;\n  }\n  /**\n   * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n   *\n   * @private\n   */\n  _cleanup() {\n    this.leaveAll();\n    this.join = noop;\n  }\n  /**\n   * Produces an `error` packet.\n   *\n   * @param {Object} err - error object\n   *\n   * @private\n   */\n  _error(err) {\n    this.packet({\n      type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n      data: err\n    });\n  }\n  /**\n   * Disconnects this client.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // disconnect this socket (the connection might be kept alive for other namespaces)\n   *   socket.disconnect();\n   *\n   *   // disconnect this socket and close the underlying connection\n   *   socket.disconnect(true);\n   * })\n   *\n   * @param {Boolean} close - if `true`, closes the underlying connection\n   * @return self\n   */\n  disconnect(close = false) {\n    if (!this.connected) return this;\n    if (close) {\n      this.client._disconnect();\n    } else {\n      this.packet({\n        type: socket_io_parser_1.PacketType.DISCONNECT\n      });\n      this._onclose(\"server namespace disconnect\");\n    }\n    return this;\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.compress(false).emit(\"hello\");\n   * });\n   *\n   * @param {Boolean} compress - if `true`, compresses the sending data\n   * @return {Socket} self\n   */\n  compress(compress) {\n    this.flags.compress = compress;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n   * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n   * and is in the middle of a request-response cycle).\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n   * });\n   *\n   * @return {Socket} self\n   */\n  get volatile() {\n    this.flags.volatile = true;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n   * sender.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // the “foo” event will be broadcast to all connected clients, except this socket\n   *   socket.broadcast.emit(\"foo\", \"bar\");\n   * });\n   *\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  get broadcast() {\n    return this.newBroadcastOperator();\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // the “foo” event will be broadcast to all connected clients on this node, except this socket\n   *   socket.local.emit(\"foo\", \"bar\");\n   * });\n   *\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  get local() {\n    return this.newBroadcastOperator().local;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n   * given number of milliseconds have elapsed without an acknowledgement from the client:\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.timeout(5000).emit(\"my-event\", (err) => {\n   *     if (err) {\n   *       // the client did not acknowledge the event in the given delay\n   *     }\n   *   });\n   * });\n   *\n   * @returns self\n   */\n  timeout(timeout) {\n    this.flags.timeout = timeout;\n    return this;\n  }\n  /**\n   * Dispatch incoming event to socket listeners.\n   *\n   * @param {Array} event - event that will get emitted\n   * @private\n   */\n  dispatch(event) {\n    debug(\"dispatching an event %j\", event);\n    this.run(event, err => {\n      process.nextTick(() => {\n        if (err) {\n          return this._onerror(err);\n        }\n        if (this.connected) {\n          super.emitUntyped.apply(this, event);\n        } else {\n          debug(\"ignore packet received after disconnection\");\n        }\n      });\n    });\n  }\n  /**\n   * Sets up socket middleware.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.use(([event, ...args], next) => {\n   *     if (isUnauthorized(event)) {\n   *       return next(new Error(\"unauthorized event\"));\n   *     }\n   *     // do not forget to call next\n   *     next();\n   *   });\n   *\n   *   socket.on(\"error\", (err) => {\n   *     if (err && err.message === \"unauthorized event\") {\n   *       socket.disconnect();\n   *     }\n   *   });\n   * });\n   *\n   * @param {Function} fn - middleware function (event, next)\n   * @return {Socket} self\n   */\n  use(fn) {\n    this.fns.push(fn);\n    return this;\n  }\n  /**\n   * Executes the middleware for an incoming event.\n   *\n   * @param {Array} event - event that will get emitted\n   * @param {Function} fn - last fn call in the middleware\n   * @private\n   */\n  run(event, fn) {\n    const fns = this.fns.slice(0);\n    if (!fns.length) return fn(null);\n    function run(i) {\n      fns[i](event, function (err) {\n        // upon error, short-circuit\n        if (err) return fn(err);\n        // if no middleware left, summon callback\n        if (!fns[i + 1]) return fn(null);\n        // go on to next\n        run(i + 1);\n      });\n    }\n    run(0);\n  }\n  /**\n   * Whether the socket is currently disconnected\n   */\n  get disconnected() {\n    return !this.connected;\n  }\n  /**\n   * A reference to the request that originated the underlying Engine.IO Socket.\n   */\n  get request() {\n    return this.client.request;\n  }\n  /**\n   * A reference to the underlying Client transport connection (Engine.IO Socket object).\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n   *\n   *   socket.conn.once(\"upgrade\", () => {\n   *     console.log(socket.conn.transport.name); // prints \"websocket\"\n   *   });\n   * });\n   */\n  get conn() {\n    return this.client.conn;\n  }\n  /**\n   * Returns the rooms the socket is currently in.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   console.log(socket.rooms); // Set { <socket.id> }\n   *\n   *   socket.join(\"room1\");\n   *\n   *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n   * });\n   */\n  get rooms() {\n    return this.adapter.socketRooms(this.id) || new Set();\n  }\n  /**\n   * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n   * the callback.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.onAny((event, ...args) => {\n   *     console.log(`got event ${event}`);\n   *   });\n   * });\n   *\n   * @param listener\n   */\n  onAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n    this._anyListeners.push(listener);\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n   * the callback. The listener is added to the beginning of the listeners array.\n   *\n   * @param listener\n   */\n  prependAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n    this._anyListeners.unshift(listener);\n    return this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is received.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   const catchAllListener = (event, ...args) => {\n   *     console.log(`got event ${event}`);\n   *   }\n   *\n   *   socket.onAny(catchAllListener);\n   *\n   *   // remove a specific listener\n   *   socket.offAny(catchAllListener);\n   *\n   *   // or remove all listeners\n   *   socket.offAny();\n   * });\n   *\n   * @param listener\n   */\n  offAny(listener) {\n    if (!this._anyListeners) {\n      return this;\n    }\n    if (listener) {\n      const listeners = this._anyListeners;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyListeners = [];\n    }\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   */\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  /**\n   * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n   * the callback.\n   *\n   * Note: acknowledgements sent to the client are not included.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.onAnyOutgoing((event, ...args) => {\n   *     console.log(`sent event ${event}`);\n   *   });\n   * });\n   *\n   * @param listener\n   */\n  onAnyOutgoing(listener) {\n    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n    this._anyOutgoingListeners.push(listener);\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.prependAnyOutgoing((event, ...args) => {\n   *     console.log(`sent event ${event}`);\n   *   });\n   * });\n   *\n   * @param listener\n   */\n  prependAnyOutgoing(listener) {\n    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n    this._anyOutgoingListeners.unshift(listener);\n    return this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is sent.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   const catchAllListener = (event, ...args) => {\n   *     console.log(`sent event ${event}`);\n   *   }\n   *\n   *   socket.onAnyOutgoing(catchAllListener);\n   *\n   *   // remove a specific listener\n   *   socket.offAnyOutgoing(catchAllListener);\n   *\n   *   // or remove all listeners\n   *   socket.offAnyOutgoing();\n   * });\n   *\n   * @param listener - the catch-all listener\n   */\n  offAnyOutgoing(listener) {\n    if (!this._anyOutgoingListeners) {\n      return this;\n    }\n    if (listener) {\n      const listeners = this._anyOutgoingListeners;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyOutgoingListeners = [];\n    }\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   */\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  /**\n   * Notify the listeners for each packet sent (emit or broadcast)\n   *\n   * @param packet\n   *\n   * @private\n   */\n  notifyOutgoingListeners(packet) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const listeners = this._anyOutgoingListeners.slice();\n      for (const listener of listeners) {\n        listener.apply(this, packet.data);\n      }\n    }\n  }\n  newBroadcastOperator() {\n    const flags = Object.assign({}, this.flags);\n    this.flags = {};\n    return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);\n  }\n}\nexports.Socket = Socket;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Socket","RESERVED_EVENTS","socket_io_parser_1","require","debug_1","typed_events_1","base64id_1","broadcast_operator_1","debug","default","RECOVERABLE_DISCONNECT_REASONS","Set","noop","StrictEventEmitter","constructor","nsp","client","auth","previousSession","recovered","data","connected","acks","Map","fns","flags","server","adapter","id","sid","pid","rooms","forEach","room","join","missedPackets","packet","type","PacketType","EVENT","conn","protocol","name","generateId","_opts","connectionStateRecovery","handshake","buildHandshake","headers","request","time","Date","address","remoteAddress","xdomain","origin","secure","connection","encrypted","issued","url","query","_query","emit","ev","args","has","Error","String","length","_ids","registerAckCallback","pop","assign","opts","broadcast","except","notifyOutgoingListeners","emitWithAck","withErr","timeout","undefined","Promise","resolve","reject","push","arg1","arg2","ack","set","timer","setTimeout","delete","call","clearTimeout","apply","to","newBroadcastOperator","in","send","write","compress","_packet","addAll","Array","isArray","leave","del","leaveAll","delAll","_onconnect","CONNECT","_onpacket","onevent","BINARY_EVENT","ACK","onack","BINARY_ACK","DISCONNECT","ondisconnect","_anyListeners","listeners","slice","listener","dispatch","self","sent","prototype","arguments","get","_onclose","_onerror","err","emitReserved","console","error","stack","reason","description","persistSession","_cleanup","_remove","_error","CONNECT_ERROR","disconnect","close","_disconnect","volatile","local","event","run","process","nextTick","emitUntyped","use","fn","i","disconnected","socketRooms","onAny","prependAny","unshift","offAny","splice","listenersAny","onAnyOutgoing","_anyOutgoingListeners","prependAnyOutgoing","offAnyOutgoing","listenersAnyOutgoing","BroadcastOperator"],"sources":["C:/Users/Michal/Desktop/projekt/chat-app/node_modules/socket.io/dist/socket.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = exports.RESERVED_EVENTS = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst typed_events_1 = require(\"./typed-events\");\nconst base64id_1 = __importDefault(require(\"base64id\"));\nconst broadcast_operator_1 = require(\"./broadcast-operator\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nconst RECOVERABLE_DISCONNECT_REASONS = new Set([\n    \"transport error\",\n    \"transport close\",\n    \"forced close\",\n    \"ping timeout\",\n    \"server shutting down\",\n    \"forced server close\",\n]);\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\",\n]);\nfunction noop() { }\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */\nclass Socket extends typed_events_1.StrictEventEmitter {\n    /**\n     * Interface to a `Client` for a given `Namespace`.\n     *\n     * @param {Namespace} nsp\n     * @param {Client} client\n     * @param {Object} auth\n     * @package\n     */\n    constructor(nsp, client, auth, previousSession) {\n        super();\n        this.nsp = nsp;\n        this.client = client;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted to the client, the data attribute and the rooms will be restored.\n         */\n        this.recovered = false;\n        /**\n         * Additional information that can be attached to the Socket instance and which will be used in the\n         * {@link Server.fetchSockets()} method.\n         */\n        this.data = {};\n        /**\n         * Whether the socket is currently connected or not.\n         *\n         * @example\n         * io.use((socket, next) => {\n         *   console.log(socket.connected); // false\n         *   next();\n         * });\n         *\n         * io.on(\"connection\", (socket) => {\n         *   console.log(socket.connected); // true\n         * });\n         */\n        this.connected = false;\n        this.acks = new Map();\n        this.fns = [];\n        this.flags = {};\n        this.server = nsp.server;\n        this.adapter = this.nsp.adapter;\n        if (previousSession) {\n            this.id = previousSession.sid;\n            this.pid = previousSession.pid;\n            previousSession.rooms.forEach((room) => this.join(room));\n            this.data = previousSession.data;\n            previousSession.missedPackets.forEach((packet) => {\n                this.packet({\n                    type: socket_io_parser_1.PacketType.EVENT,\n                    data: packet,\n                });\n            });\n            this.recovered = true;\n        }\n        else {\n            if (client.conn.protocol === 3) {\n                // @ts-ignore\n                this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n            }\n            else {\n                this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n            }\n            if (this.server._opts.connectionStateRecovery) {\n                this.pid = base64id_1.default.generateId();\n            }\n        }\n        this.handshake = this.buildHandshake(auth);\n    }\n    /**\n     * Builds the `handshake` BC object\n     *\n     * @private\n     */\n    buildHandshake(auth) {\n        return {\n            headers: this.request.headers,\n            time: new Date() + \"\",\n            address: this.conn.remoteAddress,\n            xdomain: !!this.request.headers.origin,\n            // @ts-ignore\n            secure: !!this.request.connection.encrypted,\n            issued: +new Date(),\n            url: this.request.url,\n            // @ts-ignore\n            query: this.request._query,\n            auth,\n        };\n    }\n    /**\n     * Emits to this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.emit(\"hello\", \"world\");\n     *\n     *   // all serializable datastructures are supported (no need to call JSON.stringify)\n     *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n     *\n     *   // with an acknowledgement from the client\n     *   socket.emit(\"hello\", \"world\", (val) => {\n     *     // ...\n     *   });\n     * });\n     *\n     * @return Always returns `true`.\n     */\n    emit(ev, ...args) {\n        if (exports.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        // access last argument to see if it's an ACK callback\n        if (typeof data[data.length - 1] === \"function\") {\n            const id = this.nsp._ids++;\n            debug(\"emitting packet with ack id %d\", id);\n            this.registerAckCallback(id, data.pop());\n            packet.id = id;\n        }\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        // @ts-ignore\n        if (this.nsp.server.opts.connectionStateRecovery) {\n            // this ensures the packet is stored and can be transmitted upon reconnection\n            this.adapter.broadcast(packet, {\n                rooms: new Set([this.id]),\n                except: new Set(),\n                flags,\n            });\n        }\n        else {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet, flags);\n        }\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * io.on(\"connection\", async (socket) => {\n     *   // without timeout\n     *   const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     *   // with a specific timeout\n     *   try {\n     *     const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     *   } catch (err) {\n     *     // the client did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @return a Promise that will be fulfilled when the client acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined;\n        return new Promise((resolve, reject) => {\n            args.push((arg1, arg2) => {\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                }\n                else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * @private\n     */\n    registerAckCallback(id, ack) {\n        const timeout = this.flags.timeout;\n        if (timeout === undefined) {\n            this.acks.set(id, ack);\n            return;\n        }\n        const timer = setTimeout(() => {\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n            this.acks.delete(id);\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks.set(id, (...args) => {\n            clearTimeout(timer);\n            ack.apply(this, [null, ...args]);\n        });\n    }\n    /**\n     * Targets a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients in the “room-101” room, except this socket\n     *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // the code above is equivalent to:\n     *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms (a client will be notified at most once)\n     *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        return this.newBroadcastOperator().to(room);\n    }\n    /**\n     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect all clients in the \"room-101\" room, except this socket\n     *   socket.in(\"room-101\").disconnectSockets();\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.newBroadcastOperator().in(room);\n    }\n    /**\n     * Excludes a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     *   // and this socket\n     *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms\n     *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        return this.newBroadcastOperator().except(room);\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.send(\"hello\");\n     *\n     *   // this is equivalent to\n     *   socket.emit(\"message\", \"hello\");\n     * });\n     *\n     * @return self\n     */\n    send(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */\n    write(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param {Object} packet - packet object\n     * @param {Object} opts - options\n     * @private\n     */\n    packet(packet, opts = {}) {\n        packet.nsp = this.nsp.name;\n        opts.compress = false !== opts.compress;\n        this.client._packet(packet, opts);\n    }\n    /**\n     * Joins a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // join a single room\n     *   socket.join(\"room1\");\n     *\n     *   // join multiple rooms\n     *   socket.join([\"room1\", \"room2\"]);\n     * });\n     *\n     * @param {String|Array} rooms - room or array of rooms\n     * @return a Promise or nothing, depending on the adapter\n     */\n    join(rooms) {\n        debug(\"join room %s\", rooms);\n        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));\n    }\n    /**\n     * Leaves a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // leave a single room\n     *   socket.leave(\"room1\");\n     *\n     *   // leave multiple rooms\n     *   socket.leave(\"room1\").leave(\"room2\");\n     * });\n     *\n     * @param {String} room\n     * @return a Promise or nothing, depending on the adapter\n     */\n    leave(room) {\n        debug(\"leave room %s\", room);\n        return this.adapter.del(this.id, room);\n    }\n    /**\n     * Leave all rooms.\n     *\n     * @private\n     */\n    leaveAll() {\n        this.adapter.delAll(this.id);\n    }\n    /**\n     * Called by `Namespace` upon successful\n     * middleware execution (ie: authorization).\n     * Socket is added to namespace array before\n     * call to join, so adapters can access it.\n     *\n     * @private\n     */\n    _onconnect() {\n        debug(\"socket connected - writing packet\");\n        this.connected = true;\n        this.join(this.id);\n        if (this.conn.protocol === 3) {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT });\n        }\n        else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT,\n                data: { sid: this.id, pid: this.pid },\n            });\n        }\n    }\n    /**\n     * Called with each packet. Called by `Client`.\n     *\n     * @param {Object} packet\n     * @private\n     */\n    _onpacket(packet) {\n        debug(\"got packet %j\", packet);\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n        }\n    }\n    /**\n     * Called upon event packet.\n     *\n     * @param {Packet} packet - packet object\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        this.dispatch(args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @param {Number} id - packet id\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function () {\n            // prevent double callbacks\n            if (sent)\n                return;\n            const args = Array.prototype.slice.call(arguments);\n            debug(\"sending ack %j\", args);\n            self.packet({\n                id: id,\n                type: socket_io_parser_1.PacketType.ACK,\n                data: args,\n            });\n            sent = true;\n        };\n    }\n    /**\n     * Called upon ack packet.\n     *\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks.get(packet.id);\n        if (\"function\" == typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            this.acks.delete(packet.id);\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon client disconnect packet.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"got disconnect packet\");\n        this._onclose(\"client namespace disconnect\");\n    }\n    /**\n     * Handles a client error.\n     *\n     * @private\n     */\n    _onerror(err) {\n        if (this.listeners(\"error\").length) {\n            this.emitReserved(\"error\", err);\n        }\n        else {\n            console.error(\"Missing error handler on `socket`.\");\n            console.error(err.stack);\n        }\n    }\n    /**\n     * Called upon closing. Called by `Client`.\n     *\n     * @param {String} reason\n     * @param description\n     * @throw {Error} optional error object\n     *\n     * @private\n     */\n    _onclose(reason, description) {\n        if (!this.connected)\n            return this;\n        debug(\"closing socket - reason %s\", reason);\n        this.emitReserved(\"disconnecting\", reason, description);\n        if (this.server._opts.connectionStateRecovery &&\n            RECOVERABLE_DISCONNECT_REASONS.has(reason)) {\n            debug(\"connection state recovery is enabled for sid %s\", this.id);\n            this.adapter.persistSession({\n                sid: this.id,\n                pid: this.pid,\n                rooms: [...this.rooms],\n                data: this.data,\n            });\n        }\n        this._cleanup();\n        this.nsp._remove(this);\n        this.client._remove(this);\n        this.connected = false;\n        this.emitReserved(\"disconnect\", reason, description);\n        return;\n    }\n    /**\n     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n     *\n     * @private\n     */\n    _cleanup() {\n        this.leaveAll();\n        this.join = noop;\n    }\n    /**\n     * Produces an `error` packet.\n     *\n     * @param {Object} err - error object\n     *\n     * @private\n     */\n    _error(err) {\n        this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect this socket (the connection might be kept alive for other namespaces)\n     *   socket.disconnect();\n     *\n     *   // disconnect this socket and close the underlying connection\n     *   socket.disconnect(true);\n     * })\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return self\n     */\n    disconnect(close = false) {\n        if (!this.connected)\n            return this;\n        if (close) {\n            this.client._disconnect();\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n            this._onclose(\"server namespace disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.compress(false).emit(\"hello\");\n     * });\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Socket} self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n     * });\n     *\n     * @return {Socket} self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n     * sender.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients, except this socket\n     *   socket.broadcast.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get broadcast() {\n        return this.newBroadcastOperator();\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients on this node, except this socket\n     *   socket.local.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        return this.newBroadcastOperator().local;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the client:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.timeout(5000).emit(\"my-event\", (err) => {\n     *     if (err) {\n     *       // the client did not acknowledge the event in the given delay\n     *     }\n     *   });\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Dispatch incoming event to socket listeners.\n     *\n     * @param {Array} event - event that will get emitted\n     * @private\n     */\n    dispatch(event) {\n        debug(\"dispatching an event %j\", event);\n        this.run(event, (err) => {\n            process.nextTick(() => {\n                if (err) {\n                    return this._onerror(err);\n                }\n                if (this.connected) {\n                    super.emitUntyped.apply(this, event);\n                }\n                else {\n                    debug(\"ignore packet received after disconnection\");\n                }\n            });\n        });\n    }\n    /**\n     * Sets up socket middleware.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.use(([event, ...args], next) => {\n     *     if (isUnauthorized(event)) {\n     *       return next(new Error(\"unauthorized event\"));\n     *     }\n     *     // do not forget to call next\n     *     next();\n     *   });\n     *\n     *   socket.on(\"error\", (err) => {\n     *     if (err && err.message === \"unauthorized event\") {\n     *       socket.disconnect();\n     *     }\n     *   });\n     * });\n     *\n     * @param {Function} fn - middleware function (event, next)\n     * @return {Socket} self\n     */\n    use(fn) {\n        this.fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming event.\n     *\n     * @param {Array} event - event that will get emitted\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */\n    run(event, fn) {\n        const fns = this.fns.slice(0);\n        if (!fns.length)\n            return fn(null);\n        function run(i) {\n            fns[i](event, function (err) {\n                // upon error, short-circuit\n                if (err)\n                    return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1])\n                    return fn(null);\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Whether the socket is currently disconnected\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * A reference to the request that originated the underlying Engine.IO Socket.\n     */\n    get request() {\n        return this.client.request;\n    }\n    /**\n     * A reference to the underlying Client transport connection (Engine.IO Socket object).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n     *\n     *   socket.conn.once(\"upgrade\", () => {\n     *     console.log(socket.conn.transport.name); // prints \"websocket\"\n     *   });\n     * });\n     */\n    get conn() {\n        return this.client.conn;\n    }\n    /**\n     * Returns the rooms the socket is currently in.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.rooms); // Set { <socket.id> }\n     *\n     *   socket.join(\"room1\");\n     *\n     *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n     * });\n     */\n    get rooms() {\n        return this.adapter.socketRooms(this.id) || new Set();\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAny((event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is received.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   }\n     *\n     *   socket.onAny(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAny(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAny();\n     * });\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n     * the callback.\n     *\n     * Note: acknowledgements sent to the client are not included.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.prependAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is sent.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   }\n     *\n     *   socket.onAnyOutgoing(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAnyOutgoing(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAnyOutgoing();\n     * });\n     *\n     * @param listener - the catch-all listener\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent (emit or broadcast)\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n    newBroadcastOperator() {\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);\n    }\n}\nexports.Socket = Socket;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}